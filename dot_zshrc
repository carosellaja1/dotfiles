# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# ============================================
# Oh My Zsh Configuration
# ============================================

export ZSH="$HOME/.oh-my-zsh"
ZSH_THEME="powerlevel10k/powerlevel10k"
zstyle ':omz:update' mode auto
ENABLE_CORRECTION="true"

plugins=(
  git
  zsh-autosuggestions
)

source $ZSH/oh-my-zsh.sh

# ============================================
# Zsh Options
# ============================================

# Completion behavior
setopt always_to_end          # Move cursor to end of word after completion
setopt auto_list              # Automatically list choices on ambiguous completion
setopt auto_menu              # Show completion menu on successive tab press
setopt completeinword         # Complete from both ends of a word
setopt hash_list_all          # Hash entire command path on completion

# Directory navigation
setopt auto_cd                # cd by typing directory name if it's not a command
setopt auto_pushd             # Make cd push old directory onto stack
setopt pushd_ignore_dups      # Don't push duplicates onto the stack

# Globbing and expansion
setopt extended_glob          # Treat #, ~, and ^ as part of patterns
setopt glob_dots              # Include dotfiles in globs
setopt nocaseglob             # Case-insensitive globbing
setopt nonomatch              # Avoid "zsh: no matches found" errors
setopt numeric_glob_sort      # Sort globs numerically
setopt noshwordsplit          # Use zsh-style word splitting

# History
setopt append_history         # Append to history file (default, but explicit for share_history)
setopt extended_history       # Save timestamp and duration to history
setopt hist_expire_dups_first # Delete duplicates first when HISTFILE exceeds HISTSIZE
setopt hist_find_no_dups      # Don't show duplicates when searching history
setopt hist_ignore_space      # Don't save commands starting with space
setopt hist_reduce_blanks     # Remove superfluous blanks from history
setopt hist_verify            # Show command with history expansion before running
setopt histignorespace        # Remove commands starting with space from history
setopt inc_append_history     # Save history entries immediately
setopt share_history          # Share history between shell instances

HISTFILE="${HOME}/.zsh_history"
HISTSIZE=100000
SAVEHIST=${HISTSIZE}

# Miscellaneous
setopt correct_all            # Autocorrect commands
setopt interactivecomments    # Allow comments in interactive mode
setopt longlistjobs           # Display PID when suspending processes
setopt no_beep                # Silence all bells
setopt notify                 # Report background job status immediately
setopt prompt_subst           # Allow expansion in prompts

# ============================================
# Completions
# ============================================

# Fast compinit - only rebuild completions once per day
autoload -Uz compinit
if [[ -n ~/.zcompdump(#qN.mh+24) ]]; then
  compinit
else
  compinit -C
fi

# Docker CLI completions
fpath=("$HOME/.docker/completions" $fpath)

# ============================================
# Environment Variables
# ============================================

# Editor
export EDITOR="vim"
export VISUAL="$EDITOR"

# Less pager
export LESS="-R -F -X"
export LESSHISTFILE=-

# ripgrep config
export RIPGREP_CONFIG_PATH="$HOME/.ripgreprc"

# Go
export GOPATH="$HOME/go"
export GO111MODULE=on

# pnpm
export PNPM_HOME="$HOME/Library/pnpm"

# Project-specific
export LOCALAGI_CUSTOM_ACTIONS_DIR="$HOME/Projects/LocalAGI/example/custom_actions"

# ============================================
# PATH Configuration
# ============================================

# Add directories to PATH (avoid duplicates)
typeset -U path  # Keep PATH entries unique

path=(
  "$GOPATH/bin"
  "$PNPM_HOME"
  "$HOME/.lmstudio/bin"
  "$HOME/.nexus/bin"
  $path
)

export PATH

# ============================================
# Tool Integrations
# ============================================

# Man pages with bat (syntax highlighting)
if command -v bat &>/dev/null; then
  export MANPAGER="sh -c 'col -bx | bat -l man -p'"
  export MANROFFOPT="-c"
fi

# Powerlevel10k prompt
[[ -f ~/.p10k.zsh ]] && source ~/.p10k.zsh

# Custom plugin loader
[[ -f ~/.zsh/plugin-loader.zsh ]] && source ~/.zsh/plugin-loader.zsh

# On-demand toolset loader
[[ -f ~/.zsh/toolsets.zsh ]] && source ~/.zsh/toolsets.zsh

# Local environment
[[ -f "$HOME/.local/bin/env" ]] && source "$HOME/.local/bin/env"

# API keys and secrets (for MCP servers, etc.)
[[ -f "$HOME/.config/secrets/api-keys.env" ]] && source "$HOME/.config/secrets/api-keys.env"

# Langflow uv environment
[[ -f "$HOME/.langflow/uv/env" ]] && source "$HOME/.langflow/uv/env"

# iTerm2 shell integration
[[ -f "$HOME/.iterm2_shell_integration.zsh" ]] && source "$HOME/.iterm2_shell_integration.zsh"

# Kiro IDE integration
[[ "$TERM_PROGRAM" == "kiro" ]] && source "$(kiro --locate-shell-integration-path zsh)"

# LocalStack
[[ -f "$HOME/.localstack/localstack_setup.sh" ]] && source "$HOME/.localstack/localstack_setup.sh"

# ============================================
# Lazy-loaded Tools (for faster shell startup)
# ============================================

# Conda - only initialize when first used
conda() {
  unfunction conda
  eval "$('/opt/anaconda3/bin/conda' 'shell.zsh' 'hook')"
  conda "$@"
}

# Google Cloud SDK - loaded on-demand via: toolset load gcloud

# ============================================
# Aliases - Sane Defaults
# ============================================

# Safety prompts
alias cp='cp -iv'
alias mv='mv -iv'
alias rm='rm -i'
alias mkdir='mkdir -pv'
alias grep='grep --color=always'

# Quick directory navigation
alias cd..='cd ../'
alias ..='cd ../'
alias ...='cd ../../'
alias .3='cd ../../../'
alias .4='cd ../../../../'
alias .5='cd ../../../../../'
alias .6='cd ../../../../../../'
alias ~='cd ~'

# Utility shortcuts
alias kill='kill -9'
alias rmd='rm -rf'
alias ax='chmod a+x'
alias path='echo -e ${PATH//:/\\n}'
alias sourcea='source ${HOME}/.zshrc'

# Dev tools with preferred options
alias shfmt='shfmt -ci -bn -i 2'
alias sc='shellcheck --exclude=2001,2148'

# Prefer modern alternatives when available
(( $+commands[bat] )) && alias cat='bat'
(( $+commands[prettyping] )) && alias ping='prettyping --nolegend'
(( $+commands[htop] )) && alias top='htop'

# System monitoring
alias memHogs='ps wwaxm -o pid,stat,vsize,rss,time,command | head -10'
alias cpuHogs='ps wwaxr -o pid,stat,%cpu,time,command | head -10'

# ============================================
# Aliases - Directory Listing (eza/exa/colorls/ls)
# ============================================

if eza --icons &>/dev/null; then
  alias ls='eza --git --icons'
  alias l='eza --git --icons -lF'
  alias ll='eza -lahF --git --icons'
  alias lll='eza -1F --git --icons'
  alias llm='ll --sort=modified'
  alias la='eza -lbhHigUmuSa --color-scale --git --icons'
  alias lx='eza -lbhHigUmuSa@ --color-scale --git --icons'
  alias lt='eza --tree --level=2 --icons'
  alias llt='eza -lahF --tree --level=2 --icons'
  alias ltt='eza -lahF --icons | grep "$(date +"%d %b")"'
elif exa --icons &>/dev/null; then
  alias ls='exa --git --icons'
  alias l='exa --git --icons -lF'
  alias ll='exa -lahF --git --icons'
  alias lll='exa -1F --git --icons'
  alias llm='ll --sort=modified'
  alias la='exa -lbhHigUmuSa --color-scale --git --icons'
  alias lx='exa -lbhHigUmuSa@ --color-scale --git --icons'
  alias lt='exa --tree --level=2 --icons'
  alias llt='exa -lahF --tree --level=2 --icons'
  alias ltt='exa -lahF --icons | grep "$(date +"%d %b")"'
elif command -v exa &>/dev/null; then
  alias ls='exa --git'
  alias l='exa --git -lF'
  alias ll='exa -lahF --git'
  alias lll='exa -1F --git'
  alias llm='ll --sort=modified'
  alias la='exa -lbhHigUmuSa --color-scale --git'
  alias lx='exa -lbhHigUmuSa@ --color-scale --git'
  alias lt='exa --tree --level=2'
  alias llt='exa -lahF --tree --level=2'
  alias ltt='exa -lahF | grep "$(date +"%d %b")"'
elif command -v colorls &>/dev/null; then
  alias ll='colorls -1A --git-status'
  alias ls='colorls -A'
  alias ltt='colorls -A | grep "$(date +"%d %b")"'
elif [[ $(command -v ls) =~ gnubin || $OSTYPE =~ linux ]]; then
  alias ls='ls --color=auto'
  alias ll='ls -FlAhpv --color=auto'
  alias ltt='ls -FlAhpv | grep "$(date +"%d %b")"'
else
  alias ls='ls -G'
  alias ll='ls -FGlAhpv'
  alias ltt='ls -FlAhpv | grep "$(date +"%d %b")"'
fi

# ============================================
# Aliases - File Operations
# ============================================

alias numFiles='echo $(ls -1 | wc -l)'
alias make1mb='mkfile 1m ./1MB.dat'
alias make5mb='mkfile 5m ./5MB.dat'
alias make10mb='mkfile 10m ./10MB.dat'

# ============================================
# Aliases - Git
# ============================================

alias diff='git difftool'
alias fetch='git fetch origin'
alias gamend='git commit --amend'
alias gap='git add -p'
alias gba='git branch -a'
alias gc='git --no-pager commit'
alias gcl='git clone --recursive'
alias gcm='git --no-pager commit -m'
alias gcv='git --no-pager commit --no-verify'
alias ginitsubs='git submodule update --init --recursive'
alias gundo='git reset --soft HEAD^'
alias gs='git --no-pager status -s --untracked-files=all'
alias gsearch='git rev-list --all | xargs git grep -F'
alias gss='git remote update && git status -uno'
alias gsubs='git submodule update --recursive --remote'
alias gup='git remote update -p; git merge --ff-only @{u}'
alias undopush='git push -f origin HEAD^:master'
alias unstage='git reset HEAD'
alias gl='git log --pretty=format:"%C(yellow)%h\\ %ad%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate --date=short'

# Git-Extras aliases (https://github.com/tj/git-extras)
(( $+commands[git-extras] )) && {
  alias obliterate='git obliterate'
  alias release='git-release'
  alias rename-branch='git rename-branch'
  alias rename-tag='git rename-tag'
  alias ignore='git ignore'
  alias ginfo='git info --no-config'
  alias del-sub='git delete-submodule'
  alias del-tag='git delete-tag'
  alias changelog='git changelog'
  alias garchive='git archive'
  alias greset='git reset'
  alias gclear='git clear-soft'
  alias gbrowse='git browse'
  alias gtimes='git utimes'
}

# ============================================
# Functions - General
# ============================================

# Show all processes owned by current user
mine() {
  ps "$@" -u "${USER}" -o pid,%cpu,%mem,start,time,bsdtime,command
}

# Print all tput colors to terminal
colors() {
  for i in {0..255}; do
    print -Pn "%K{$i}  %k%F{$i}${(l:3::0:)i}%f " ${${(M)$((i%6)):#3}:+$'\n'}
  done
}

# cd and list directory contents
cd() {
  builtin cd "$@" || return 1
  ll
}

# Create directory and cd into it
mcd() {
  mkdir -pv "$1" && cd "$1"
}

# ============================================
# Functions - File Operations
# ============================================

# Create ZIP archive of a folder or file
zipf() { zip -r "$1".zip "$1"; }

# Copy file contents to clipboard (macOS)
copyfile() {
  if [[ -n "$1" && -f "$1" ]]; then
    pbcopy < "$1"
  else
    echo "File not found: $1"
    return 1
  fi
}

# Backup file with timestamp
buf() {
  local filename="$1"
  local filetime=$(date +%Y%m%d_%H%M%S)
  cp -a "${filename}" "${filename}_${filetime}"
}

# Batch change file extensions
chgext() {
  local f
  for f in *."$1"; do mv "$f" "${f%.$1}.$2"; done
}

# Convert JSON to YAML
j2y() {
  python3 -c 'import sys, yaml, json; yaml.safe_dump(json.load(sys.stdin), sys.stdout, default_flow_style=False)' < "$1"
}

# Convert YAML to JSON
y2j() {
  python3 -c 'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout, indent=4)' < "$1"
}

# Compare MD5 hash to file
md5Check() {
  local md5="$1"
  local file="$2"

  if ! command -v md5sum &>/dev/null; then
    echo "Cannot find 'md5sum' utility"
    return 1
  fi

  [[ ! -e "$file" ]] && { echo "Cannot find $file"; return 1; }

  local filemd5=$(md5sum "$file" | awk '{print $1}')

  if [[ "$filemd5" == "$md5" ]]; then
    echo "✓ MD5 hashes match"
    return 0
  else
    echo "✗ MD5 hashes do not match"
    return 1
  fi
}

# Extract various archive formats (with verbose option)
extract() {
  local opt verbose
  local OPTIND=1

  while getopts "hv" opt; do
    case "$opt" in
      h)
        cat <<EOF
Usage: extract [option] <archives>
Options:
  -h  Show this help
  -v  Verbose output
EOF
        return 0
        ;;
      v) verbose='v' ;;
      ?) extract -h >&2; return 1 ;;
    esac
  done
  shift $((OPTIND - 1))

  [[ $# -eq 0 ]] && { extract -h; return 1; }

  while [[ $# -gt 0 ]]; do
    if [[ -f "$1" ]]; then
      case "$1" in
        *.tar.bz2|*.tbz|*.tbz2) tar "x${verbose}jf" "$1" ;;
        *.tar.gz|*.tgz)         tar "x${verbose}zf" "$1" ;;
        *.tar.xz)               tar "x${verbose}Jf" "$1" ;;
        *.tar.Z)                uncompress "$1"; tar "x${verbose}f" "${1:0:-2}" ;;
        *.bz2)                  bunzip2 "$1" ;;
        *.deb)                  dpkg-deb -x${verbose} "$1" "${1:0:-4}" ;;
        *.pax.gz)               gunzip "$1"; pax -r -f "${1:0:-3}" ;;
        *.gz)                   gunzip "$1" ;;
        *.pax)                  pax -r -f "$1" ;;
        *.pkg)                  pkgutil --expand "$1" "${1:0:-4}" ;;
        *.rar)                  unrar x "$1" ;;
        *.rpm)                  rpm2cpio "$1" | cpio -idm${verbose} ;;
        *.tar)                  tar "x${verbose}f" "$1" ;;
        *.txz)                  mv "$1" "${1:0:-4}.tar.xz"; tar "x${verbose}Jf" "${1:0:-4}.tar.xz" ;;
        *.xz)                   xz --decompress "$1" ;;
        *.zip|*.war|*.jar)      unzip "$1" ;;
        *.Z)                    uncompress "$1" ;;
        *.7z)                   7z x "$1" ;;
        *)                      echo "'$1' cannot be extracted via extract" >&2 ;;
      esac
    else
      echo "extract: '$1' is not a valid file" >&2
    fi
    shift
  done
}

# ============================================
# Functions - Git
# ============================================

# Git add (default: all)
ga() { git add "${@:-.}"; }

# Apply gitignore to already committed files
applyignore() {
  git ls-files -ci --exclude-standard -z | xargs -0 git rm --cached
}

# Print URL of current git repository
gurl() {
  local remotename="${1:-origin}"
  local remote=$(git remote -v | awk '/^'"${remotename}"'.*\(push\)$/ {print $2}')
  [[ -z "$remote" ]] && return 1
  local host=$(echo "$remote" | perl -pe 's/.*@//;s/:.*//')
  local user_repo=$(echo "$remote" | perl -pe 's/.*://;s/\.git$//')
  echo "https://${host}/${user_repo}"
}

# Interactive git rollback
rollback() {
  _is_clean() {
    if [[ -n $(git diff --shortstat 2>/dev/null | tail -n1) ]]; then
      echo "Your branch is dirty, please commit your changes"
      return 1
    fi
    return 0
  }

  _commit_exists() {
    git rev-list --quiet "$1" 2>/dev/null
    if [[ $? -ne 0 ]]; then
      echo "Commit $1 does not exist"
      return 1
    fi
    return 0
  }

  if [[ -z $(git symbolic-ref HEAD 2>/dev/null) ]]; then
    echo "You're not in a git repository"
    return 1
  fi

  if ! _is_clean || ! _commit_exists "$1"; then
    return 1
  fi

  echo "WARNING: This will change your history and move HEAD back to commit $1"
  read "RESP?Continue? [y/N] "
  if [[ "$RESP" =~ ^[Yy]$ ]]; then
    read "KEEP?Keep changes in working tree? [y/N] "
    if [[ "$KEEP" =~ ^[Yy]$ ]]; then
      echo "Rolling back to $1 with unstaged changes"
      git reset "$1"
    else
      echo "Rolling back to $1 with clean working tree"
      git reset --hard "$1"
    fi
  fi
}

# ============================================
# macOS Specific
# ============================================

if [[ "$OSTYPE" == darwin* ]]; then

  # Clipboard
  alias cpwd='pwd | tr -d "\n" | pbcopy'            # Copy working path to clipboard
  alias cl='fc -e -|pbcopy'                         # Copy last command output to clipboard

  # System
  alias caff='caffeinate -ism'                      # Run command without letting Mac sleep
  alias cleanDS="find . -type f -name '*.DS_Store' -ls -delete"
  alias showHidden='defaults write com.apple.finder AppleShowAllFiles TRUE'
  alias hideHidden='defaults write com.apple.finder AppleShowAllFiles FALSE'
  alias cleanupLS="/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -kill -r -domain local -domain system -domain user && killall Finder"

  # Screenshots (to clipboard)
  alias capc='screencapture -c'                     # Capture screen to clipboard
  alias capic='screencapture -i -c'                 # Capture selection to clipboard
  alias capiwc='screencapture -i -w -c'             # Capture window to clipboard

  # Screenshots (to file)
  CAPTURE_FOLDER="${HOME}/Pictures/Screenshots"

  cap() { screencapture "${CAPTURE_FOLDER}/capture-$(date +%Y%m%d_%H%M%S).png"; }
  capi() { screencapture -i "${CAPTURE_FOLDER}/capture-$(date +%Y%m%d_%H%M%S).png"; }
  capiw() { screencapture -i -w "${CAPTURE_FOLDER}/capture-$(date +%Y%m%d_%H%M%S).png"; }

  # Spotlight
  alias spot-off="sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist"
  alias spot-on="sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist"
  alias spot-file="lsof -c '/mds$/'"                # Find file causing mds to hang

  spotlight() { mdfind "kMDItemDisplayName == '${1}'wc"; }

  # Finder
  f() { open -a "Finder" "${1:-.}"; }               # Open Finder at path (default: current dir)

  finderpath() {
    # Get path of frontmost Finder window
    osascript -e 'tell application "Finder"' \
      -e "if (${1-1} <= (count Finder windows)) then" \
      -e "get POSIX path of (target of window ${1-1} as alias)" \
      -e 'else' \
      -e 'get POSIX path of (desktop as alias)' \
      -e 'end if' \
      -e 'end tell' 2>/dev/null
  }

  # Quicklook
  ql() { qlmanage -p "$@" &>/dev/null; }

  # Remove quarantine from downloaded files
  unquarantine() {
    local attr
    for attr in com.apple.metadata:kMDItemDownloadedDate \
                com.apple.metadata:kMDItemWhereFroms \
                com.apple.quarantine; do
      xattr -r -d "$attr" "$@"
    done
  }

  # Pipe HTML to Safari
  browser() {
    local file=$(mktemp -t browser.XXXXXX.html)
    cat /dev/stdin > "$file"
    open -a Safari "$file"
  }

fi

# ============================================
# Shell Hooks (keep at end)
# ============================================

# direnv - auto-load .envrc files
eval "$(direnv hook zsh)"

# zoxide - smarter cd command (use: z <partial-path>)
eval "$(zoxide init zsh)"
